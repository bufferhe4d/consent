\appendix
\section{PBS based on blind RSA}
Let $N, e, d$ be RSA modulus, exponent and private key respectively. We assume there exists shares $d_1, d_2$ of an RSA private key $d$. Such that $d = d_1 + d_2$. This can be done by a joint protocol between $\client$ and $\signserv$ or by a dealer. $G$ is a random map for mapping low entropy $\pseudo$ to a group element. $H$ is a random oracle.

\pseudocodeblock{
\textbf{ Client}(d_1,) \<\< \textbf{ Agent}(d_2) \\[0.1\baselineskip][\hline]
\<\< \\[-0.5\baselineskip]
\pseudo \sample \mathcal{D}\\
\eta \gets G(\pseudo) - d_1\\
\< \sendmessageright*{\eta} \< \agentsecret \gets \eta - d_2\pclb
\pcintertext[dotted]{Request} \\
r \sample \ZZ_N^*\\
\rho \gets H(m)\cdot r^e \< \sendmessageright*{\rho} \<\\
\<\< \tilde{\sigma} \gets \rho^{\agentsecret}\\
\< \sendmessageleft*{\tilde{\sigma}} \< \\
\sigma \gets \tilde{\sigma}\cdot\rho^{G(\pseudo)}\cdot r^{-1} \<\<\\
\pccomment{Check if RSA signature verifies}\<\<\\
\pcif \sigma^e = H(m)\<\<\\
    \t \pcreturn \sigma\<\<\\
\pcreturn \bot\<\<
}

\section{Server Aided Digital Signatures (SADS)}
\abdullah{The construction is a bit weird. A key generation is run (on a password input) by a trusted third party. I am not sure if some parts of this could be done by the client}. 
Notation for the protocol below:
\begin{itemize}
    \item $\mathsf{RSA.Gen}$: RSA Key Generator
    \item $H$: Random Oracle
    \item $\mathsf{MAC}_{key}(m)$: Message authentication code with key $key$ for message $m$.
    \item $\mathsf{Enc}_{key}(m)$: Symmetric encryption with key $key$ for message $m$
    \item $\mathsf{Dec}_{key}(c)$: Symmetric decryption with key $key$ for ciphertext $c$
    \item $\mathsf{PKE.Gen}()$: Key generator of a PKE.
    \item $\mathsf{PKE.Enc}_{pk}(m)$: PKE encryption with key $pk$ for message $m$
    \item $\mathsf{PKE.Dec}_{sk}(c)$: PKE decryption with key $sk$ for message $c$
    \item $\mathsf{Sig.Gen}()$: Key generator of a signature scheme.
    \item $\mathsf{Sig.Sign}_{sk}(m)$: Signing algorithm of a signature scheme with secret key $sk$ for message $m$.
    \item $\mathsf{Sig.Ver}_{pk}(m, sig)$: Verification algorithm of a signature scheme with public key $pk$ on a message $m$ with signature $sig$.
    
\end{itemize}
\begin{figure}
\begin{pchstack}[center, space=0.2cm, boxed]
 
    \procedure[linenumbering]{$\mathsf{KeyGen}(\pseudo)$}{
        \delta_1, \delta_2 \sample \ZZ_p^*\\
        key \gets H(H(\pseudo)^{\delta_1 + \delta_2}\mod p)\\
        a_1 \gets H(H(\pseudo)^{\delta_1} \mod p)\\
        a_2 \gets H(H(\pseudo)^{\delta_2} \mod p)\\
        e, d, N \sample \mathsf{RSA.Gen(\secparam)}\\
        d_1 \sample \ZZ_N^*\\
        d_2 = d - d_1\\
        A \gets \mathsf{Enc}_{key}(d_1||N||\mathsf{MAC}_{key}(d_1||N))\\
        ssk_1, spk_1 \gets \mathsf{Sig.Gen}(\secpar)\\
        sk_1, pk_1 \gets \mathsf{PKE.Gen}(\secpar)\\
        sk_2, pk_2 \gets \mathsf{PKE.Gen}(\secpar)\\
        \pcreturn \textbf{to Server 1} (A, \delta_1, a_2, ssk_1, sk_1)\\
        \pcreturn \textbf{to Server 2} (\delta_2, d_2, a_1, sk_2)\\
        \pcreturn \textbf{to All} (p, N, e, spk_1, pk_1, pk_2)
    }
    
\end{pchstack}
\caption{KeyGen for SADS}
\label{SADSKeyGen}
\end{figure}


\begin{figure}
\pseudocodeblock[xshift=-80pt] 
{
 \mathsf{Server1}(A, \delta_1, a_2, ssk_1, sk_1)  \<\< \client(\pseudo, M)  \<\< \mathsf{Server2}(\delta_2, d_2, a_1, sk_2)\\
  \<\< b \sample \bin^{\secpar} \<\< \\
  \<\< c \gets H(\pseudo)^b \mod p \<\< \\
  t_1 \gets c^{\delta_1} \mod p\< \sendmessageleft{length=1.5cm,top=$c$}\<\<\\
  v_1 \gets \mathsf{Sig}_{ssk_1}(t_1||c) \< \sendmessageright{length=1.5cm,top={$(v_1, t_1, A)$}}  \<\< \\
  \<\< \pcabort \pcif \mathsf{Ver}_{spk_1}(t_1||c, v_1) \neq 1 \<\< \\
  \<\< u_1\gets t_1^{b^{-1}} \mod p \<\< \\
  \<\< auth_1 \gets \mathsf{MAC}_{H(u_1)}(M||c) \<\< \\
  \<\< r_1 \sample \bin^{\secpar} \<\< \\
  \<\< eau_1 \sample \mathsf{PKE.Enc}_{pk_2}(auth_1, r_1) \<\< \\
  \< \<\< \sendmessageright{length=1.5cm,top={$(c, M, eau_1)$}}\\
  \<\<  \<\< auth_1', r_1' \gets \mathsf{PKE.Dec}_{sk_2}(eau_1)\\
  \<\< \<\<\pcabort \pcif auth_1 \neq \mathsf{MAC}_{a_1}(M||c)  \\
  \<\< \<\< s_1\gets H(M)^{d_2} \mod N \\
  \<\< \<\< t_2\gets c^{\delta_2} \mod p \\
  \< \<\< \sendmessageleft{length=1.5cm,top={$(s_1, t_2)$}}\\
   \<\< u_2 \gets t_2^{b^{-1}} \mod p \<\< \\
   \<\< key' \gets H(u_1\cdot u_2 \mod p) \<\<\\
   \<\< d_1, N, auth' \gets \mathsf{Dec}_{key'}(A) \<\<\\
   \<\< \pcabort \pcif \mathsf{MAC}_{key'}(d1||N) \neq auth' \<\< \\
   \<\< s_2 \gets s_1\cdot H(M)^{d_1} \mod N \<\< \\
   \<\< \pcabort \pcif s_2^{e}\neq H(M) \mod N \<\< \\
   \<\< auth_2 \gets \mathsf{MAC}_{H(u_2)}(M||c) \<\< \\
   \<\< r_2 \sample \bin^{\secpar} \<\< \\
  \<\< eau_2 \sample \mathsf{PKE.Enc}_{pk_1}(auth_2, r_2) \<\< \\
  \<\sendmessageleft{length=1.5cm,top=$eau_2$}\<\<\\
  auth_2', r_2' \gets \mathsf{PKE.Dec}_{sk_1}(eau_2) \< \<  \<\< \\
  \pcabort \pcif auth_2' \neq \mathsf{MAC}_{a_2}(M||c) \< \<  \<\< \\ 
  \text{\textcolor{red}{Not clear when $M$ is sent.}} \<\<\<\<\\
}
\caption{SADS Protocol Construction}
\label{SADS Construction}
\end{figure}